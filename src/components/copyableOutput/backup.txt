"use client";
import React, { memo, useEffect, useMemo, useState } from "react";
import styles from "./CopyableOutput.module.css";
import {
  ColorFormat,
  FormatterOptions,
  ThemeFormat,
} from "@/types/outputFormat";
import { generateColorPalette } from "@/lib/generateColorPalette";
import { formatters } from "@/utils/formatters/formatters";
import { SyntaxHighlighter } from "@/components/syntaxHighlighter/SyntaxHighlighter";
import { applyThemeToDocument } from "@/utils/applyTheme";
import { ThemeType } from "@/types/theme";
import { debounce } from "@/utils/debounce";

interface CopyableOutputProps {
  appearance: ThemeType;
  accentColor: string;
  grayColor: string;
  backgroundColor: string;
  darkmodeBackgroundColor: string;
}

// eslint-disable-next-line react/display-name
export const CopyableOutput = memo(
  ({
    appearance,
    accentColor,
    grayColor,
    backgroundColor,
    darkmodeBackgroundColor,
  }: CopyableOutputProps) => {
    const [selectedFormat, setSelectedFormat] =
      useState<ThemeFormat>("cssVariables");
    const [colorFormat, setColorFormat] = useState<ColorFormat>("hex");
    const [colorPalettes, setColorPalettes] = useState<{
      light: ReturnType<typeof generateColorPalette> | null;
      dark: ReturnType<typeof generateColorPalette> | null;
    }>({ light: null, dark: null });

    // State for debounced syntax highlighting
    const [debouncedKey, setDebouncedKey] = useState("");
    const [debouncedCode, setDebouncedCode] = useState("");

    // Debounced update for syntax highlighting
    const updateSyntaxHighlighter = useMemo(
      () =>
        debounce((newKey: string, newCode: string) => {
          setDebouncedKey(newKey);
          setDebouncedCode(newCode);
        }, 300),
      [],
    );

    // Generate the syntax key
    const syntaxKey = useMemo(
      () =>
        `${accentColor}-${grayColor}-${backgroundColor}-${selectedFormat}-${colorFormat}`,
      [accentColor, grayColor, backgroundColor, selectedFormat, colorFormat],
    );

    // Generate palettes with debounce
    const generatePalettes = useMemo(
      () =>
        debounce(
          (
            currentAppearance: ThemeType,
            bgColor: string,
            darkBgColor: string,
            gray: string,
            accent: string,
          ) => {
            const lightPalette = generateColorPalette({
              appearance: "light",
              background: bgColor,
              gray: gray,
              accent: accent,
            });

            const darkPalette = generateColorPalette({
              appearance: "dark",
              background: darkBgColor,
              gray: gray,
              accent: accent,
            });

            setColorPalettes({ light: lightPalette, dark: darkPalette });

            applyThemeToDocument(
              currentAppearance === "light" ? bgColor : darkBgColor,
              currentAppearance === "light" ? lightPalette : darkPalette,
            );
          },
          50,
        ),
      [],
    );

    // Effect for palette generation
    useEffect(() => {
      generatePalettes(
        appearance,
        backgroundColor,
        darkmodeBackgroundColor,
        grayColor,
        accentColor,
      );

      return () => {
        generatePalettes.cancel();
      };
    }, [
      appearance,
      backgroundColor,
      darkmodeBackgroundColor,
      grayColor,
      accentColor,
      generatePalettes,
    ]);

    // Effect for updating syntax highlighter
    useEffect(() => {
      if (!colorPalettes.light || !colorPalettes.dark) return;

      const options: FormatterOptions = {
        colorFormat,
        backgroundColor,
        darkmodeBackgroundColor,
      };

      const formattedCode = formatters[selectedFormat](
        colorPalettes.light,
        colorPalettes.dark,
        options,
      );

      updateSyntaxHighlighter(syntaxKey, formattedCode);

      return () => {
        updateSyntaxHighlighter.cancel();
      };
    }, [
      colorPalettes,
      selectedFormat,
      colorFormat,
      backgroundColor,
      darkmodeBackgroundColor,
      syntaxKey,
      updateSyntaxHighlighter,
    ]);

    return (
      <div className={styles.container}>
        <div className={styles.formatSelection}>
          <label className={styles.label}>Output Format:</label>
          <div className={styles.radioGroup}>
            {(["radix", "shadcn", "tailwind", "cssVariables"] as const).map(
              (format) => (
                <label key={format} className={styles.radioLabel}>
                  <input
                    type="radio"
                    name="format"
                    value={format}
                    checked={selectedFormat === format}
                    onChange={(e) =>
                      setSelectedFormat(e.target.value as ThemeFormat)
                    }
                    className={styles.radioInput}
                  />
                  {format === "cssVariables" ? "CSS Variables" : format}
                </label>
              ),
            )}
          </div>

          {/* Color format selection - now available for all formats */}
          <div className={styles.subFormatSelection}>
            <label className={styles.label}>Color Format:</label>
            <div className={styles.radioGroup}>
              {(["hex", "rgb", "hsl", "hslValues"] as const).map((format) => (
                <label key={format} className={styles.radioLabel}>
                  <input
                    type="radio"
                    name="colorFormat"
                    value={format}
                    checked={colorFormat === format}
                    onChange={(e) =>
                      setColorFormat(e.target.value as ColorFormat)
                    }
                    className={styles.radioInput}
                  />
                  {format === "hslValues" ? "HSL Values" : format.toUpperCase()}
                </label>
              ))}
            </div>
          </div>
        </div>

        {colorPalettes.light && colorPalettes.dark && (
          <div
            className={styles.output}
            style={{
              minHeight: "400px",
              overflow: "auto",
            }}
          >
            <div className={styles.codeBlock}>
              <h2 className={styles.codeBlockTitle}>StyleSheet Output</h2>

              <SyntaxHighlighter key={debouncedKey} code={debouncedCode} />
            </div>
          </div>
        )}
      </div>
    );
  },
);
